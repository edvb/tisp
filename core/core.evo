;;; core.evo
def list(... lst) "Create list" lst
def quit() '~No REPL to quit from~

def defmacro
  Macro (args ... body)
    "Define named macro, with argument list and body
  First element of arguments is name of macro
  Also see: def"
    cond
      (pair? args)
        list 'def (fst args) (list 'Macro (rst args) ... body)
      else
        error 'defmacro "expected macro name and argument List, recieved "
              typeof args

;;; fst/rst

def snd(x)   fst(rst(x))
def ffst(x)  fst(fst(x))
def rfst(x)  rst(fst(x))
def rrst(x)  rst(rst(x))
def fffst(x) fst(fst(fst(x)))
def ffrst(x) fst(fst(rst(x)))
def frfst(x) fst(rst(fst(x)))
def frrst(x) fst(rst(rst(x)))
def rffst(x) rst(fst(fst(x)))
def rfrst(x) rst(fst(rst(x)))
def rrfst(x) rst(rst(fst(x)))
def rrrst(x) rst(rst(rst(x)))

;;; Types

def any?(x)         True
def void?(x)        (= Type(x) TVoid)
def nil?(x)         (= Type(x) TNil)
def integer?(x)     (= Type(x) Int) ; TODO shorten type querry funcs: integer? -> int?
def decimal?(x)     (= Type(x) Dec)
def ratio?(x)       (= Type(x) Ratio)
def string?(x)      (= Type(x) Str)
def symbol?(x)      (= Type(x) Sym)
def primitive?(x)   (= Type(x) Prim)
def specialform?(x) (= Type(x) Form)
def function?(x)    (= Type(x) Func)
def macro?(x)       (= Type(x) Macro)
def record?(x)      (= Type(x) Rec)
def pair?(x)        (= Type(x) Pair)
def atom?(x)        (not pair?(x))
def list?(x)        (if pair?(x) list?(rst(x)) not(x))
def boolean?(x)     (or (= x True) nil?(x))
def true?(x)        (= x True)
def false?          nil?
def builtin?(x)     (or primitive?(x) specialform?(x))
def procedure?(x)   (or builtin?(x) (or function?(x) macro?(x)))
def rational?(x)    (or integer?(x) ratio?(x))
def number?(x)      (or rational?(x) decimal?(x))

def Bool(x)
  if x
    True
    Nil

defmacro assert(expr)
  `(unless ,expr
     (error 'assert "assertion " ',expr " failed"))

;;; Control Flow

; TODO if b = pair and fst b = else use rst b
defmacro (if con a b)
  "Execute a if condition con is true, otherwise run b"
  [cond [con a] [True b]]
def else True
defmacro (when con ... body)
  "Execute body if condition con is true"
  [cond [con [do ... body]]]
defmacro (unless con ... body)
  "Execute body unless condition, con, is true"
  [cond [[not con] [do ... body]]]

defmacro (let vars ... body)
  "Execute body with new local variables in vars
  vars is a list of name and value pairs"
  [(list* 'Func ()
      (append
        (map
          @(list* 'def (fst it) (rst it))
          vars)
        body))]

(defmacro (recur proc vars ... body)
  "Do recursion within body by calling proc with values for vars
  Also see: let"
  (list 'let
        (list*
          (list proc (list* 'Func (map fst vars) body))
          vars)
        (list* proc (map fst vars))))

; TODO support else that is run if no values are equal
(defmacro (switch val ... body)
  "Compare value to first element in each body statement, only running line where they are equal"
  (list* 'cond (map
                 @`((= ,val ,(fst it)) ,(snd it))
                 body)))

(defmacro (quasiquote expr)
  "Recursively quote the given expression
  Automatically quotes each element within the expression, but evaluates the
  element if it is labeled with the unquote macro.
  Can be shortened with the ` prefix.
  Also see: quote, unquote, unquote-splice"
  (def (check form)
    (unless (and (pair? (rst form)) (nil? (rrst form)))
      (error (fst form) "invalid form " form)))
  (def (quasicons a d)
    (if (pair? d)
      (if (= (fst d) 'quote)
        (if (and (pair? a) (= (fst a) 'quote))
          (list 'quote (list* (snd a) (snd d)))
          (if (nil? (snd d))
            (list 'list a)
            (list list* a d)))
        (if (member (fst d) '(list list*))
          (list* (fst d) a (rst d))
          (list list* a d)))
      (list list* a d)))
  (recur f ((expr expr) (n 0))
    (cond
      ((nil? expr) Nil)
      ((atom? expr) (list 'quote expr))
      ((= (fst expr) 'quasiquote)
       (check expr)
       (quasicons ''quasiquote (f (rst expr) (+ n 1))))
      ((= (fst expr) 'unquote)
       (check expr)
       (if (= n 0)
         (snd expr)
         (quasicons ''unquote (f (rst expr) (- n 1)))))
      ((= (fst expr) 'unquote-splice)
       (check expr)
       (if (= n 0)
         (error 'unquote-splice "invalid context for " (snd expr))
         (quasicons ''unquote-splice (f (rst expr) (- n 1)))))
      ((and (= n 0) (and (pair? (fst expr)) (= (ffst expr) 'unquote-splice)))
       (check (fst expr))
       (let (d: (f (rst expr) n))
         (if d
           (list 'append (frfst expr) d)
           (frfst expr))))
      (else (quasicons (f (fst expr) n) (f (rst expr) n))))))

(defmacro (unquote expr)
  "Unquote expression so its evaluated before placed into the quasiquote
  Can be shortened with the , prefix
  Errors if called outside quasiquote
  Also see: quasiquote, unquote-splice, quote"
  (error 'unquote "called outside of quasiquote"))
(defmacro (unquote-splice expr)
  "Unquote and splice the expression into the quasiquote
  If the value evaluated is a list, embedded each element into the quasiquote
  Can be shortened with the ,@ prefix
  Errors if called outside a quasiquote of a list
  Also see: quasiquote, unquote, quote"
  (error 'unquote-splice "called outside of quasiquote"))

;;; Logic

def False Nil
def (not x)
  if x Nil True
; Use a macro so arguments aren't evaluated all at once
defmacro (and a b)
  "Return b if a is not nil, else return nil"
  [if a b Nil]
defmacro (or a b)
  "Return a if not nil, else return b"
  [if a a b]
defmacro (xor? a b)
  "Exclusive or, either a or b are true, but not if both are true"
  [and [or a b] [not [and a b]]]
